py::enum_<MsgType_ToDevice>(m, "MsgType_ToDevice")
    .value("Ping", MsgType_ToDevice::Ping)
    .value("RecordCalibrationPointTangential", MsgType_ToDevice::RecordCalibrationPointTangential)
    .value("RecordCalibrationPointNormal", MsgType_ToDevice::RecordCalibrationPointNormal)
    .value("RequestCalibrationPointsTangential", MsgType_ToDevice::RequestCalibrationPointsTangential)
    .value("RequestCalibrationPointsNormal", MsgType_ToDevice::RequestCalibrationPointsNormal)
    .value("ACK", MsgType_ToDevice::ACK)
    .value("ClearLoadCellCalibrationPointsTangential", MsgType_ToDevice::ClearLoadCellCalibrationPointsTangential)
    .value("ClearLoadCellCalibrationPointsNormal", MsgType_ToDevice::ClearLoadCellCalibrationPointsNormal)
    .value("EnterLoadCellCalibrationModeTangential", MsgType_ToDevice::EnterLoadCellCalibrationModeTangential)
    .value("EnterLoadCellCalibrationModeNormal", MsgType_ToDevice::EnterLoadCellCalibrationModeNormal)
    .value("ExitLoadCellCalibrationModeTangential", MsgType_ToDevice::ExitLoadCellCalibrationModeTangential)
    .value("ExitLoadCellCalibrationModeNormal", MsgType_ToDevice::ExitLoadCellCalibrationModeNormal)
    .value("WriteCalibrationCoefficientsTangential", MsgType_ToDevice::WriteCalibrationCoefficientsTangential)
    .value("WriteCalibrationCoefficientsNormal", MsgType_ToDevice::WriteCalibrationCoefficientsNormal)
    .value("RecordOrientationCalibrationPoint", MsgType_ToDevice::RecordOrientationCalibrationPoint)
    .value("ClearOrientationCalibrationPoint", MsgType_ToDevice::ClearOrientationCalibrationPoint)
    .value("RequestOrientationCalibrationData", MsgType_ToDevice::RequestOrientationCalibrationData)
    .value("SetAngleOffsetCalibration", MsgType_ToDevice::SetAngleOffsetCalibration)
    .value("Handshake", MsgType_ToDevice::Handshake)
    .value("NAK", MsgType_ToDevice::NAK)
    .value("WriteConfigToFlash", MsgType_ToDevice::WriteConfigToFlash)
    .value("RequestAngle", MsgType_ToDevice::RequestAngle)
    .value("RequestConfig", MsgType_ToDevice::RequestConfig)
    .value("WriteConfig", MsgType_ToDevice::WriteConfig)
    .value("StartDataStreaming", MsgType_ToDevice::StartDataStreaming)
    .value("StopDataStreaming", MsgType_ToDevice::StopDataStreaming)
    .value("RequestFaultData", MsgType_ToDevice::RequestFaultData)
    .value("ClearFault", MsgType_ToDevice::ClearFault)
    .value("UpdateSetForce", MsgType_ToDevice::UpdateSetForce)
    .value("Home", MsgType_ToDevice::Home)
    .value("RequestDeviceInfo", MsgType_ToDevice::RequestDeviceInfo)
    .value("JogMotor", MsgType_ToDevice::JogMotor)
    .value("ToggleLED", MsgType_ToDevice::ToggleLED)
    .value("AbortMove", MsgType_ToDevice::AbortMove)
    .value("RequestOrientation", MsgType_ToDevice::RequestOrientation)
    .value("RequestCurrentForceData", MsgType_ToDevice::RequestCurrentForceData)
    .value("RequestAccelerationData", MsgType_ToDevice::RequestAccelerationData)
    .value("Restart", MsgType_ToDevice::Restart)
    .value("ResetToDefaults", MsgType_ToDevice::ResetToDefaults)
    .value("StartForceControl", MsgType_ToDevice::StartForceControl)
    .value("FirmwareUpdateStart", MsgType_ToDevice::FirmwareUpdateStart)
    .value("FirmwareUpdateChunk", MsgType_ToDevice::FirmwareUpdateChunk)
    .value("FirmwareUpdateFinalise", MsgType_ToDevice::FirmwareUpdateFinalise)
    .value("ResetAllCalibrationData", MsgType_ToDevice::ResetAllCalibrationData)
    .value("ZeroForces", MsgType_ToDevice::ZeroForces)
    ;

py::enum_<MsgType_ToHost>(m, "MsgType_ToHost")
    .value("CalibrationPointNormal", MsgType_ToHost::CalibrationPointNormal)
    .value("CalibrationPointTangential", MsgType_ToHost::CalibrationPointTangential)
    .value("ACK", MsgType_ToHost::ACK)
    .value("Handshake", MsgType_ToHost::Handshake)
    .value("OrientationCalibrationData", MsgType_ToHost::OrientationCalibrationData)
    .value("ERR", MsgType_ToHost::ERR)
    .value("Reserved1", MsgType_ToHost::Reserved1)
    .value("AllCalibrationData", MsgType_ToHost::AllCalibrationData)
    .value("ConfigData", MsgType_ToHost::ConfigData)
    .value("CurrentData", MsgType_ToHost::CurrentData)
    .value("FaultData", MsgType_ToHost::FaultData)
    .value("DeviceInfo", MsgType_ToHost::DeviceInfo)
    .value("OrientationData", MsgType_ToHost::OrientationData)
    .value("AccelerationData", MsgType_ToHost::AccelerationData)
    .value("CRCError", MsgType_ToHost::CRCError)
    ;

py::enum_<fault_reason_t>(m, "fault_reason_t")
    .value("F_NORMAL_I2C_ERROR", fault_reason_t::F_NORMAL_I2C_ERROR)
    .value("F_NORMAL_RESERVED", fault_reason_t::F_NORMAL_RESERVED)
    .value("F_NORMAL_STALE_DATA", fault_reason_t::F_NORMAL_STALE_DATA)
    .value("F_NORMAL_ADC_ERROR", fault_reason_t::F_NORMAL_ADC_ERROR)
    .value("F_NORMAL_ZERO_OUTSIDE_EXPECTED", fault_reason_t::F_NORMAL_ZERO_OUTSIDE_EXPECTED)
    .value("F_NORMAL_OVERLOAD", fault_reason_t::F_NORMAL_OVERLOAD)
    .value("F_TANGENTIAL_I2C_ERROR", fault_reason_t::F_TANGENTIAL_I2C_ERROR)
    .value("F_TANGENTIAL_RESERVED", fault_reason_t::F_TANGENTIAL_RESERVED)
    .value("F_TANGENTIAL_STALE_DATA", fault_reason_t::F_TANGENTIAL_STALE_DATA)
    .value("F_TANGENTIAL_ADC_ERROR", fault_reason_t::F_TANGENTIAL_ADC_ERROR)
    .value("F_TANGENTIAL_ZERO_OUTSIDE_EXPECTED", fault_reason_t::F_TANGENTIAL_ZERO_OUTSIDE_EXPECTED)
    .value("F_TANGENTIAL_OVERLOAD", fault_reason_t::F_TANGENTIAL_OVERLOAD)
    .value("F_HOMING_TIMEOUT", fault_reason_t::F_HOMING_TIMEOUT)
    .value("F_MOTOR_TIMEOUT", fault_reason_t::F_MOTOR_TIMEOUT)
    .value("F_LIMIT_WHILE_ACTIVE", fault_reason_t::F_LIMIT_WHILE_ACTIVE)
    .value("F_MOVE_OUT_OF_RANGE", fault_reason_t::F_MOVE_OUT_OF_RANGE)
    .value("F_COULD_NOT_ADD_TO_QUEUE", fault_reason_t::F_COULD_NOT_ADD_TO_QUEUE)
    .value("F_COULD_NOT_ACQUIRE_FORCE_LOCK", fault_reason_t::F_COULD_NOT_ACQUIRE_FORCE_LOCK)
    .value("F_IMPOSSIBLE_STATE", fault_reason_t::F_IMPOSSIBLE_STATE)
    .value("F_PID_DELAY_TOO_LONG", fault_reason_t::F_PID_DELAY_TOO_LONG)
    .value("F_UART_NO_INIT", fault_reason_t::F_UART_NO_INIT)
    .value("F_UART_RUNNING_TIMEOUT", fault_reason_t::F_UART_RUNNING_TIMEOUT)
    .value("F_UART_ACK_TIMEOUT", fault_reason_t::F_UART_ACK_TIMEOUT)
    .value("F_UART_RESEND_LIMIT", fault_reason_t::F_UART_RESEND_LIMIT)
    .value("F_UART_NO_ACK", fault_reason_t::F_UART_NO_ACK)
    .value("F_NO_MEMORY", fault_reason_t::F_NO_MEMORY)
    .value("F_COULD_NOT_ACQUIRE_LOCK", fault_reason_t::F_COULD_NOT_ACQUIRE_LOCK)
    .value("F_CONFIG_UPDATE_WHILE_RUNNING", fault_reason_t::F_CONFIG_UPDATE_WHILE_RUNNING)
    .value("F_LAST_REASON", fault_reason_t::F_LAST_REASON)
    ;

py::enum_<error_reason_t>(m, "error_reason_t")
    .value("E_SUCCESS", error_reason_t::E_SUCCESS)
    .value("E_ACK_RECEIVED", error_reason_t::E_ACK_RECEIVED)
    .value("E_OPERATION_FAILED", error_reason_t::E_OPERATION_FAILED)
    .value("E_TIMEOUT", error_reason_t::E_TIMEOUT)
    .value("E_QUEUE_FULL", error_reason_t::E_QUEUE_FULL)
    .value("E_UNRECOGNISED_COMMAND", error_reason_t::E_UNRECOGNISED_COMMAND)
    .value("E_INVALID_MESSAGE", error_reason_t::E_INVALID_MESSAGE)
    .value("E_INVALID_DATA", error_reason_t::E_INVALID_DATA)
    .value("E_INVALID_STATE", error_reason_t::E_INVALID_STATE)
    .value("E_BOUNDS_CHECK_FAILED", error_reason_t::E_BOUNDS_CHECK_FAILED)
    .value("E_GPIO_FAIL", error_reason_t::E_GPIO_FAIL)
    .value("E_LOCK_FAILED", error_reason_t::E_LOCK_FAILED)
    .value("E_NULL_POINTER", error_reason_t::E_NULL_POINTER)
    .value("E_FIRMWARE_UPDATE_INIT_FAILED", error_reason_t::E_FIRMWARE_UPDATE_INIT_FAILED)
    .value("E_FIRMWARE_UPDATE_FAILED_TO_WRITE", error_reason_t::E_FIRMWARE_UPDATE_FAILED_TO_WRITE)
    .value("E_FIRMWARE_UPDATE_CRC_CHECK_FAILED", error_reason_t::E_FIRMWARE_UPDATE_CRC_CHECK_FAILED)
    .value("E_FIRMWARE_UPDATE_NOT_IN_PROGRESS", error_reason_t::E_FIRMWARE_UPDATE_NOT_IN_PROGRESS)
    .value("E_FIRMWARE_UPDATE_WRONG_SIZE_RECEIVED", error_reason_t::E_FIRMWARE_UPDATE_WRONG_SIZE_RECEIVED)
    .value("E_FIRMWARE_UPDATE_COULD_NOT_SET_BOOT_PARTITION", error_reason_t::E_FIRMWARE_UPDATE_COULD_NOT_SET_BOOT_PARTITION)
    .value("E_FLASH_READ_FAILED", error_reason_t::E_FLASH_READ_FAILED)
    .value("E_FLASH_WRITE_FAILED", error_reason_t::E_FLASH_WRITE_FAILED)
    .value("E_FLASH_ERASE_FAILED", error_reason_t::E_FLASH_ERASE_FAILED)
    .value("E_FLASH_COMMIT_FAILED", error_reason_t::E_FLASH_COMMIT_FAILED)
    .value("E_FLASH_WROTE_DEFAULT", error_reason_t::E_FLASH_WROTE_DEFAULT)
    .value("E_FLASH_ERROR", error_reason_t::E_FLASH_ERROR)
    .value("E_PROTOCOL_VERSION_MAJOR_ONLY", error_reason_t::E_PROTOCOL_VERSION_MAJOR_ONLY)
    .value("E_HANDSHAKE_INCOMPLETE", error_reason_t::E_HANDSHAKE_INCOMPLETE)
    .value("E_I2C1_INIT_FAILED", error_reason_t::E_I2C1_INIT_FAILED)
    .value("E_LOADCELL_I2C_READ_FAILED_T", error_reason_t::E_LOADCELL_I2C_READ_FAILED_T)
    .value("E_LOADCELL_I2C_READ_FAILED_N", error_reason_t::E_LOADCELL_I2C_READ_FAILED_N)
    .value("E_LOADCELL_I2C_WRITE_FAILED_T", error_reason_t::E_LOADCELL_I2C_WRITE_FAILED_T)
    .value("E_LOADCELL_I2C_WRITE_FAILED_N", error_reason_t::E_LOADCELL_I2C_WRITE_FAILED_N)
    .value("E_LOADCELL_NO_VALID_MEASUREMENTS_T", error_reason_t::E_LOADCELL_NO_VALID_MEASUREMENTS_T)
    .value("E_LOADCELL_NO_VALID_MEASUREMENTS_N", error_reason_t::E_LOADCELL_NO_VALID_MEASUREMENTS_N)
    .value("E_LOADCELL_NOT_READY_T", error_reason_t::E_LOADCELL_NOT_READY_T)
    .value("E_LOADCELL_NOT_READY_N", error_reason_t::E_LOADCELL_NOT_READY_N)
    .value("E_LOADCELL_STATUS_NOT_0_T", error_reason_t::E_LOADCELL_STATUS_NOT_0_T)
    .value("E_LOADCELL_STATUS_NOT_0_N", error_reason_t::E_LOADCELL_STATUS_NOT_0_N)
    .value("E_LOADCELL_NOT_CALIBRATED_T", error_reason_t::E_LOADCELL_NOT_CALIBRATED_T)
    .value("E_LOADCELL_NOT_CALIBRATED_N", error_reason_t::E_LOADCELL_NOT_CALIBRATED_N)
    .value("E_LOADCELL_NOT_ENOUGH_TO_AVERAGE_T", error_reason_t::E_LOADCELL_NOT_ENOUGH_TO_AVERAGE_T)
    .value("E_LOADCELL_NOT_ENOUGH_TO_AVERAGE_N", error_reason_t::E_LOADCELL_NOT_ENOUGH_TO_AVERAGE_N)
    .value("E_LOADCELL_COULD_NOT_ALLOCATE_CACHE", error_reason_t::E_LOADCELL_COULD_NOT_ALLOCATE_CACHE)
    .value("E_ACCELEROMETER_CALIBRATION_OUT_OF_RANGE", error_reason_t::E_ACCELEROMETER_CALIBRATION_OUT_OF_RANGE)
    .value("E_ACCELEROMETER_NOT_CONNECTED", error_reason_t::E_ACCELEROMETER_NOT_CONNECTED)
    .value("E_ACCELEROMETER_INIT_FAILED", error_reason_t::E_ACCELEROMETER_INIT_FAILED)
    .value("E_ACCELEROMETER_I2C_READ_FAILED", error_reason_t::E_ACCELEROMETER_I2C_READ_FAILED)
    .value("E_ACCELEROMETER_I2C_WRITE_FAILED", error_reason_t::E_ACCELEROMETER_I2C_WRITE_FAILED)
    .value("E_ACCELEROMETER_NOT_ENOUGH_MEASUREMENTS", error_reason_t::E_ACCELEROMETER_NOT_ENOUGH_MEASUREMENTS)
    .value("E_ACCELEROMETER_NOT_READY", error_reason_t::E_ACCELEROMETER_NOT_READY)
    .value("E_ACCELEROMETER_JITTER_THRESHOLD_EXCEEDED", error_reason_t::E_ACCELEROMETER_JITTER_THRESHOLD_EXCEEDED)
    .value("E_INCLINE_OUT_OF_RANGE", error_reason_t::E_INCLINE_OUT_OF_RANGE)
    .value("E_ANGLE_I2C_READ_FAILED", error_reason_t::E_ANGLE_I2C_READ_FAILED)
    .value("E_ANGLE_I2C_WRITE_FAILED", error_reason_t::E_ANGLE_I2C_WRITE_FAILED)
    .value("E_ANGLE_NOT_READY", error_reason_t::E_ANGLE_NOT_READY)
    .value("E_LAST_REASON", error_reason_t::E_LAST_REASON)
    ;

py::enum_<status_bits_t>(m, "status_bits_t")
    .value("FAULT_BIT", status_bits_t::FAULT_BIT)
    .value("LIMIT_ACTIVE_BIT", status_bits_t::LIMIT_ACTIVE_BIT)
    .value("FORCES_ACTIVE_BIT", status_bits_t::FORCES_ACTIVE_BIT)
    .value("MOTORS_ENABLE_BIT", status_bits_t::MOTORS_ENABLE_BIT)
    .value("PID_RUNNING_BIT", status_bits_t::PID_RUNNING_BIT)
    .value("ISR_RUNNING_BIT", status_bits_t::ISR_RUNNING_BIT)
    .value("HANDSHAKE_COMPLETE_BIT", status_bits_t::HANDSHAKE_COMPLETE_BIT)
    .value("ALL_CALIBRATION_BIT", status_bits_t::ALL_CALIBRATION_BIT)
    .value("CURRENT_DIRECTION_BIT", status_bits_t::CURRENT_DIRECTION_BIT)
    .value("DATA_STREAMING_BIT", status_bits_t::DATA_STREAMING_BIT)
    .value("I2C0_ERROR_BIT", status_bits_t::I2C0_ERROR_BIT)
    .value("I2C1_ERROR_BIT", status_bits_t::I2C1_ERROR_BIT)
    .value("ACCEL_INIT_BIT", status_bits_t::ACCEL_INIT_BIT)
    .value("ANGLE_INIT_BIT", status_bits_t::ANGLE_INIT_BIT)
    .value("NORMAL_LC_INIT_BIT", status_bits_t::NORMAL_LC_INIT_BIT)
    .value("TANGENTIAL_LC_INIT_BIT", status_bits_t::TANGENTIAL_LC_INIT_BIT)
    .value("NORMAL_LC_HAS_CALIBRATION_BIT", status_bits_t::NORMAL_LC_HAS_CALIBRATION_BIT)
    .value("NORMAL_LC_NEEDS_CALIBRATION_BIT", status_bits_t::NORMAL_LC_NEEDS_CALIBRATION_BIT)
    .value("TANGENTIAL_LC_HAS_CALIBRATION_BIT", status_bits_t::TANGENTIAL_LC_HAS_CALIBRATION_BIT)
    .value("TANGENTIAL_LC_NEEDS_CALIBRATION_BIT", status_bits_t::TANGENTIAL_LC_NEEDS_CALIBRATION_BIT)
    .value("ORIENTATION_HAS_CALIBRATION_MODE_BIT", status_bits_t::ORIENTATION_HAS_CALIBRATION_MODE_BIT)
    .value("ANGLE_ERROR_BIT", status_bits_t::ANGLE_ERROR_BIT)
    .value("ACCELEROMETER_ERROR_BIT", status_bits_t::ACCELEROMETER_ERROR_BIT)
    .value("BAD_CALIBRATION_DATA_BIT", status_bits_t::BAD_CALIBRATION_DATA_BIT)
    .value("PROTOCOL_VERSION_MAJOR_MATCH_BIT", status_bits_t::PROTOCOL_VERSION_MAJOR_MATCH_BIT)
    ;

py::class_<empty_payload_t>(m, "EmptyPayload")
    .def(py::init<>())
    .def("serialize", [](empty_payload_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](empty_payload_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(empty_payload_t)) throw std::runtime_error("deserialize: wrong size"); empty_payload_t result; std::memcpy(&result, s.data(), sizeof(empty_payload_t)); return result; })
    ;

py::class_<date_t>(m, "Date")
    .def(py::init<>())
    .def_readwrite("day_y", &date_t::day_y)
    .def_readwrite("year", &date_t::year)
    .def("serialize", [](date_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](date_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(date_t)) throw std::runtime_error("deserialize: wrong size"); date_t result; std::memcpy(&result, s.data(), sizeof(date_t)); return result; })
    ;

py::class_<motor_config_t>(m, "MotorConfig")
    .def(py::init<>())
    .def_readwrite("microsteps_per_step", &motor_config_t::microsteps_per_step)
    .def_readwrite("fullsteps_per_revolution", &motor_config_t::fullsteps_per_revolution)
    .def_readwrite("fullstep_distance", &motor_config_t::fullstep_distance)
    .def_readwrite("travel", &motor_config_t::travel)
    .def_readwrite("max_acceleration", &motor_config_t::max_acceleration)
    .def_readwrite("max_rpm", &motor_config_t::max_rpm)
    .def_readwrite("max_speed", &motor_config_t::max_speed)
    .def_readwrite("approach_speed", &motor_config_t::approach_speed)
    .def_readwrite("home_speed", &motor_config_t::home_speed)
    .def_readwrite("homing_timeout", &motor_config_t::homing_timeout)
    .def("serialize", [](motor_config_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](motor_config_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(motor_config_t)) throw std::runtime_error("deserialize: wrong size"); motor_config_t result; std::memcpy(&result, s.data(), sizeof(motor_config_t)); return result; })
    ;

py::class_<pid_config_t>(m, "PidConfig")
    .def(py::init<>())
    .def_readwrite("PID_P", &pid_config_t::PID_P)
    .def_readwrite("PID_I", &pid_config_t::PID_I)
    .def_readwrite("PID_D", &pid_config_t::PID_D)
    .def_readwrite("max_deriv_control", &pid_config_t::max_deriv_control)
    .def_readwrite("max_integral_error", &pid_config_t::max_integral_error)
    .def_readwrite("settle_tollerance", &pid_config_t::settle_tollerance)
    .def_readwrite("diferential_decay", &pid_config_t::diferential_decay)
    .def_readwrite("n_settle", &pid_config_t::n_settle)
    .def_readwrite("touch_force_mn", &pid_config_t::touch_force_mn)
    .def("serialize", [](pid_config_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](pid_config_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(pid_config_t)) throw std::runtime_error("deserialize: wrong size"); pid_config_t result; std::memcpy(&result, s.data(), sizeof(pid_config_t)); return result; })
    ;

py::class_<load_cell_config_t>(m, "LoadCellConfig")
    .def(py::init<>())
    .def_readwrite("scale", &load_cell_config_t::scale)
    .def_readwrite("max_load", &load_cell_config_t::max_load)
    .def_readwrite("maximum_zero_offset", &load_cell_config_t::maximum_zero_offset)
    .def_readwrite("minimum_zero_offset", &load_cell_config_t::minimum_zero_offset)
    .def_readwrite("calibration_duration", &load_cell_config_t::calibration_duration)
    .def_readwrite("minimum_period_us", &load_cell_config_t::minimum_period_us)
    .def_readwrite("cache_length", &load_cell_config_t::cache_length)
    .def_readwrite("minimum_average", &load_cell_config_t::minimum_average)
    .def_readwrite("max_errors", &load_cell_config_t::max_errors)
    .def_readwrite("error_on_calibration", &load_cell_config_t::error_on_calibration)
    .def("serialize", [](load_cell_config_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](load_cell_config_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(load_cell_config_t)) throw std::runtime_error("deserialize: wrong size"); load_cell_config_t result; std::memcpy(&result, s.data(), sizeof(load_cell_config_t)); return result; })
    ;

py::class_<accelerometer_config_t>(m, "AccelerometerConfig")
    .def(py::init<>())
    .def_readwrite("jitter_threshold", &accelerometer_config_t::jitter_threshold)
    .def_readwrite("n_samples", &accelerometer_config_t::n_samples)
    .def_readwrite("timeout", &accelerometer_config_t::timeout)
    .def_readwrite("calibration_duration", &accelerometer_config_t::calibration_duration)
    .def_readwrite("error_on_calibration", &accelerometer_config_t::error_on_calibration)
    .def("serialize", [](accelerometer_config_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](accelerometer_config_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(accelerometer_config_t)) throw std::runtime_error("deserialize: wrong size"); accelerometer_config_t result; std::memcpy(&result, s.data(), sizeof(accelerometer_config_t)); return result; })
    ;

py::class_<config_data_t>(m, "ConfigData")
    .def(py::init<>())
    .def_readwrite("motor", &config_data_t::motor)
    .def_readwrite("pid", &config_data_t::pid)
    .def_readwrite("normal_lc", &config_data_t::normal_lc)
    .def_readwrite("tangential_lc", &config_data_t::tangential_lc)
    .def_readwrite("accelerometer", &config_data_t::accelerometer)
    .def_readwrite("config_update_timeout", &config_data_t::config_update_timeout)
    .def("serialize", [](config_data_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](config_data_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(config_data_t)) throw std::runtime_error("deserialize: wrong size"); config_data_t result; std::memcpy(&result, s.data(), sizeof(config_data_t)); return result; })
    ;

py::class_<serial_number_t>(m, "SerialNumber")
    .def(py::init<>())
    .def_readwrite("ManufacturerID", &serial_number_t::ManufacturerID)
    .def_readwrite("DeviceID", &serial_number_t::DeviceID)
    .def_readwrite("HardwareVersion", &serial_number_t::HardwareVersion)
    .def_readwrite("ProductionYear", &serial_number_t::ProductionYear)
    .def_readwrite("ProductionMonth", &serial_number_t::ProductionMonth)
    .def_readwrite("ProductionDay", &serial_number_t::ProductionDay)
    .def_readwrite("BatchNumber", &serial_number_t::BatchNumber)
    .def_readwrite("DeviceNumber", &serial_number_t::DeviceNumber)
    .def("serialize", [](serial_number_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](serial_number_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(serial_number_t)) throw std::runtime_error("deserialize: wrong size"); serial_number_t result; std::memcpy(&result, s.data(), sizeof(serial_number_t)); return result; })
    ;

py::class_<handshake_to_device_payload_t>(m, "HandshakeToDevicePayload")
    .def(py::init<>())
    .def_readwrite("protocol_version", &handshake_to_device_payload_t::protocol_version)
    .def_readwrite("date", &handshake_to_device_payload_t::date)
    .def_readwrite("hour", &handshake_to_device_payload_t::hour)
    .def_readwrite("minute", &handshake_to_device_payload_t::minute)
    .def_readwrite("second", &handshake_to_device_payload_t::second)
    .def("serialize", [](handshake_to_device_payload_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](handshake_to_device_payload_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(handshake_to_device_payload_t)) throw std::runtime_error("deserialize: wrong size"); handshake_to_device_payload_t result; std::memcpy(&result, s.data(), sizeof(handshake_to_device_payload_t)); return result; })
    ;

py::class_<handshake_to_host_payload_t>(m, "HandshakeToHostPayload")
    .def(py::init<>())
    .def_readwrite("protocol_version", &handshake_to_host_payload_t::protocol_version)
    .def_readwrite("status", &handshake_to_host_payload_t::status)
    .def_readwrite("last_n_loadcell_calibration_date", &handshake_to_host_payload_t::last_n_loadcell_calibration_date)
    .def_readwrite("last_t_loadcell_calibration_date", &handshake_to_host_payload_t::last_t_loadcell_calibration_date)
    .def_readwrite("last_orientation_calibration_date", &handshake_to_host_payload_t::last_orientation_calibration_date)
    .def_readwrite("serial_number", &handshake_to_host_payload_t::serial_number)
    .def("serialize", [](handshake_to_host_payload_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](handshake_to_host_payload_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(handshake_to_host_payload_t)) throw std::runtime_error("deserialize: wrong size"); handshake_to_host_payload_t result; std::memcpy(&result, s.data(), sizeof(handshake_to_host_payload_t)); return result; })
    ;

py::class_<device_info_t>(m, "DeviceInfo")
    .def(py::init<>())
    .def_readwrite("handshake", &device_info_t::handshake)
    .def_readwrite("firmware", &device_info_t::firmware)
    .def("serialize", [](device_info_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](device_info_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(device_info_t)) throw std::runtime_error("deserialize: wrong size"); device_info_t result; std::memcpy(&result, s.data(), sizeof(device_info_t)); return result; })
    ;

py::class_<force_data_point_t>(m, "ForceDataPoint")
    .def(py::init<>())
    .def_readwrite("device_status", &force_data_point_t::device_status)
    .def_readwrite("f_normal_mn", &force_data_point_t::f_normal_mn)
    .def_readwrite("f_tangential_mn", &force_data_point_t::f_tangential_mn)
    .def_readwrite("millis_since_start", &force_data_point_t::millis_since_start)
    .def("serialize", [](force_data_point_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](force_data_point_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(force_data_point_t)) throw std::runtime_error("deserialize: wrong size"); force_data_point_t result; std::memcpy(&result, s.data(), sizeof(force_data_point_t)); return result; })
    ;

py::class_<acceleration_data_t>(m, "AccelerationData")
    .def(py::init<>())
    .def_readwrite("x", &acceleration_data_t::x)
    .def_readwrite("y", &acceleration_data_t::y)
    .def_readwrite("z", &acceleration_data_t::z)
    .def_readwrite("t", &acceleration_data_t::t)
    .def("serialize", [](acceleration_data_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](acceleration_data_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(acceleration_data_t)) throw std::runtime_error("deserialize: wrong size"); acceleration_data_t result; std::memcpy(&result, s.data(), sizeof(acceleration_data_t)); return result; })
    ;

py::class_<orientation_data_t>(m, "OrientationData")
    .def(py::init<>())
    .def_readwrite("incline", &orientation_data_t::incline)
    .def_readwrite("roll", &orientation_data_t::roll)
    .def("serialize", [](orientation_data_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](orientation_data_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(orientation_data_t)) throw std::runtime_error("deserialize: wrong size"); orientation_data_t result; std::memcpy(&result, s.data(), sizeof(orientation_data_t)); return result; })
    ;

py::class_<angle_payload_t>(m, "AnglePayload")
    .def(py::init<>())
    .def_readwrite("angle_mrad", &angle_payload_t::angle_mrad)
    .def("serialize", [](angle_payload_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](angle_payload_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(angle_payload_t)) throw std::runtime_error("deserialize: wrong size"); angle_payload_t result; std::memcpy(&result, s.data(), sizeof(angle_payload_t)); return result; })
    ;

py::class_<set_force_payload_t>(m, "SetForcePayload")
    .def(py::init<>())
    .def_readwrite("force_mn", &set_force_payload_t::force_mn)
    .def("serialize", [](set_force_payload_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](set_force_payload_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(set_force_payload_t)) throw std::runtime_error("deserialize: wrong size"); set_force_payload_t result; std::memcpy(&result, s.data(), sizeof(set_force_payload_t)); return result; })
    ;

py::class_<jog_payload_t>(m, "JogPayload")
    .def(py::init<>())
    .def_readwrite("distance_mm", &jog_payload_t::distance_mm)
    .def("serialize", [](jog_payload_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](jog_payload_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(jog_payload_t)) throw std::runtime_error("deserialize: wrong size"); jog_payload_t result; std::memcpy(&result, s.data(), sizeof(jog_payload_t)); return result; })
    ;

py::class_<data_rate_payload_t>(m, "DataRatePayload")
    .def(py::init<>())
    .def_readwrite("rate_hz", &data_rate_payload_t::rate_hz)
    .def("serialize", [](data_rate_payload_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](data_rate_payload_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(data_rate_payload_t)) throw std::runtime_error("deserialize: wrong size"); data_rate_payload_t result; std::memcpy(&result, s.data(), sizeof(data_rate_payload_t)); return result; })
    ;

py::class_<load_cell_calibration_coef_t>(m, "LoadCellCalibrationCoef")
    .def(py::init<>())
    .def_readwrite("OFFSET_B", &load_cell_calibration_coef_t::OFFSET_B)
    .def_readwrite("GAIN_B", &load_cell_calibration_coef_t::GAIN_B)
    .def_readwrite("TCO", &load_cell_calibration_coef_t::TCO)
    .def_readwrite("TCG", &load_cell_calibration_coef_t::TCG)
    .def_readwrite("SOT_TCG", &load_cell_calibration_coef_t::SOT_TCG)
    .def_readwrite("SOT_TCO", &load_cell_calibration_coef_t::SOT_TCO)
    .def_readwrite("SOT_B", &load_cell_calibration_coef_t::SOT_B)
    .def_readwrite("GAIN_T", &load_cell_calibration_coef_t::GAIN_T)
    .def_readwrite("OFFSET_T", &load_cell_calibration_coef_t::OFFSET_T)
    .def_readwrite("SOT_T", &load_cell_calibration_coef_t::SOT_T)
    .def("serialize", [](load_cell_calibration_coef_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](load_cell_calibration_coef_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(load_cell_calibration_coef_t)) throw std::runtime_error("deserialize: wrong size"); load_cell_calibration_coef_t result; std::memcpy(&result, s.data(), sizeof(load_cell_calibration_coef_t)); return result; })
    ;

py::class_<load_cell_calibration_data_t>(m, "LoadCellCalibrationData")
    .def(py::init<>())
    .def_readwrite("coefficients", &load_cell_calibration_data_t::coefficients)
    .def_readwrite("date", &load_cell_calibration_data_t::date)
    .def("serialize", [](load_cell_calibration_data_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](load_cell_calibration_data_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(load_cell_calibration_data_t)) throw std::runtime_error("deserialize: wrong size"); load_cell_calibration_data_t result; std::memcpy(&result, s.data(), sizeof(load_cell_calibration_data_t)); return result; })
    ;

py::class_<angle_calibration_data_t>(m, "AngleCalibrationData")
    .def(py::init<>())
    .def_readwrite("angle_offset_mrad", &angle_calibration_data_t::angle_offset_mrad)
    .def_readwrite("date", &angle_calibration_data_t::date)
    .def("serialize", [](angle_calibration_data_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](angle_calibration_data_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(angle_calibration_data_t)) throw std::runtime_error("deserialize: wrong size"); angle_calibration_data_t result; std::memcpy(&result, s.data(), sizeof(angle_calibration_data_t)); return result; })
    ;

py::class_<orientation_calibration_data_t>(m, "OrientationCalibrationData")
    .def(py::init<>())
    .def_readwrite("orientation_offsets", &orientation_calibration_data_t::orientation_offsets)
    .def_readwrite("date", &orientation_calibration_data_t::date)
    .def("serialize", [](orientation_calibration_data_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](orientation_calibration_data_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(orientation_calibration_data_t)) throw std::runtime_error("deserialize: wrong size"); orientation_calibration_data_t result; std::memcpy(&result, s.data(), sizeof(orientation_calibration_data_t)); return result; })
    ;

py::class_<calibration_data_t>(m, "CalibrationData")
    .def(py::init<>())
    .def_readwrite("normal_lc", &calibration_data_t::normal_lc)
    .def_readwrite("tangential_lc", &calibration_data_t::tangential_lc)
    .def_readwrite("orientation", &calibration_data_t::orientation)
    .def_readwrite("angle", &calibration_data_t::angle)
    .def("serialize", [](calibration_data_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](calibration_data_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(calibration_data_t)) throw std::runtime_error("deserialize: wrong size"); calibration_data_t result; std::memcpy(&result, s.data(), sizeof(calibration_data_t)); return result; })
    ;

py::class_<load_cell_calibration_point_t>(m, "LoadCellCalibrationPoint")
    .def(py::init<>())
    .def_readwrite("true_force", &load_cell_calibration_point_t::true_force)
    .def_readwrite("true_temperature", &load_cell_calibration_point_t::true_temperature)
    .def_readwrite("bridge_raw", &load_cell_calibration_point_t::bridge_raw)
    .def_readwrite("temperature_raw", &load_cell_calibration_point_t::temperature_raw)
    .def_readwrite("date", &load_cell_calibration_point_t::date)
    .def("serialize", [](load_cell_calibration_point_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](load_cell_calibration_point_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(load_cell_calibration_point_t)) throw std::runtime_error("deserialize: wrong size"); load_cell_calibration_point_t result; std::memcpy(&result, s.data(), sizeof(load_cell_calibration_point_t)); return result; })
    ;

py::class_<force_calib_true_values_t>(m, "ForceCalibTrueValues")
    .def(py::init<>())
    .def_readwrite("true_force_mN", &force_calib_true_values_t::true_force_mN)
    .def_readwrite("true_temperature_C", &force_calib_true_values_t::true_temperature_C)
    .def("serialize", [](force_calib_true_values_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](force_calib_true_values_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(force_calib_true_values_t)) throw std::runtime_error("deserialize: wrong size"); force_calib_true_values_t result; std::memcpy(&result, s.data(), sizeof(force_calib_true_values_t)); return result; })
    ;

py::class_<orientation_calib_info_t>(m, "OrientationCalibInfo")
    .def(py::init<>())
    .def_readwrite("number", &orientation_calib_info_t::number)
    .def("serialize", [](orientation_calib_info_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](orientation_calib_info_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(orientation_calib_info_t)) throw std::runtime_error("deserialize: wrong size"); orientation_calib_info_t result; std::memcpy(&result, s.data(), sizeof(orientation_calib_info_t)); return result; })
    ;

py::class_<firmware_update_start_t>(m, "FirmwareUpdateStart")
    .def(py::init<>())
    .def_readwrite("total_size", &firmware_update_start_t::total_size)
    .def_readwrite("chunk_size", &firmware_update_start_t::chunk_size)
    .def_readwrite("total_chunks", &firmware_update_start_t::total_chunks)
    .def("serialize", [](firmware_update_start_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](firmware_update_start_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(firmware_update_start_t)) throw std::runtime_error("deserialize: wrong size"); firmware_update_start_t result; std::memcpy(&result, s.data(), sizeof(firmware_update_start_t)); return result; })
    ;

py::class_<firmware_update_chunk_t>(m, "FirmwareUpdateChunk")
    .def(py::init<>())
    .def_readwrite("offset", &firmware_update_chunk_t::offset)
    .def_readwrite("valid_bytes", &firmware_update_chunk_t::valid_bytes)
    .def("serialize", [](firmware_update_chunk_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](firmware_update_chunk_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(firmware_update_chunk_t)) throw std::runtime_error("deserialize: wrong size"); firmware_update_chunk_t result; std::memcpy(&result, s.data(), sizeof(firmware_update_chunk_t)); return result; })
    ;

py::class_<firmware_update_finalise_t>(m, "FirmwareUpdateFinalise")
    .def(py::init<>())
    .def_readwrite("crc", &firmware_update_finalise_t::crc)
    .def("serialize", [](firmware_update_finalise_t& s) { return py::bytes(reinterpret_cast<const char*>(&s), sizeof(s)); })
    .def("sizeof", [](firmware_update_finalise_t& s) { return sizeof(s); })
    .def_static("deserialize", [](py::bytes b) { std::string s = b; if (s.size() != sizeof(firmware_update_finalise_t)) throw std::runtime_error("deserialize: wrong size"); firmware_update_finalise_t result; std::memcpy(&result, s.data(), sizeof(firmware_update_finalise_t)); return result; })
    ;
